// Generated by BUCKLESCRIPT VERSION 1.9.3, PLEASE EDIT WITH CARE
'use strict';

var List        = require("bs-platform/lib/js/list.js");
var $$Array     = require("bs-platform/lib/js/array.js");
var $$String    = require("bs-platform/lib/js/string.js");
var Caml_array  = require("bs-platform/lib/js/caml_array.js");
var Caml_int32  = require("bs-platform/lib/js/caml_int32.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");

function mapCharToMove(c) {
  var switcher = c - 66 | 0;
  if (switcher > 16 || switcher < 0) {
    return /* NotValid */4;
  } else {
    switch (switcher) {
      case 0 : 
          return /* B */1;
      case 4 : 
          return /* F */0;
      case 10 : 
          return /* L */3;
      case 1 : 
      case 2 : 
      case 3 : 
      case 5 : 
      case 6 : 
      case 7 : 
      case 8 : 
      case 9 : 
      case 11 : 
      case 12 : 
      case 13 : 
      case 14 : 
      case 15 : 
          return /* NotValid */4;
      case 16 : 
          return /* R */2;
      
    }
  }
}

function mapCommandToMove(command) {
  if (command === "") {
    return /* [] */0;
  } else {
    var length = command.length;
    var rest = $$String.sub(command, 1, length - 1 | 0);
    var tail = mapCommandToMove(rest);
    var firstCommand = mapCharToMove(Caml_string.get(command, 0));
    return /* :: */[
            firstCommand,
            tail
          ];
  }
}

function evaluateMove(pluto, m) {
  var direction = pluto[/* direction */2];
  var position = pluto[/* position */1];
  var board = pluto[/* board */0];
  var heigth = List.length(board);
  var width = List.length(List.nth(board, 0));
  var y = position[1];
  var x = position[0];
  var newPosition;
  var exit = 0;
  switch (direction) {
    case 0 : 
        if (m !== 1) {
          if (m !== 0) {
            newPosition = /* tuple */[
              x,
              y
            ];
          } else {
            exit = 1;
          }
        } else {
          exit = 2;
        }
        break;
    case 1 : 
        if (m !== 1) {
          if (m !== 0) {
            newPosition = /* tuple */[
              x,
              y
            ];
          } else {
            exit = 2;
          }
        } else {
          exit = 1;
        }
        break;
    case 2 : 
        if (m !== 1) {
          if (m !== 0) {
            newPosition = /* tuple */[
              x,
              y
            ];
          } else {
            exit = 3;
          }
        } else {
          exit = 4;
        }
        break;
    case 3 : 
        if (m !== 1) {
          if (m !== 0) {
            newPosition = /* tuple */[
              x,
              y
            ];
          } else {
            exit = 4;
          }
        } else {
          exit = 3;
        }
        break;
    
  }
  switch (exit) {
    case 1 : 
        newPosition = /* tuple */[
          Caml_int32.mod_(x + 1 | 0, heigth),
          y
        ];
        break;
    case 2 : 
        newPosition = /* tuple */[
          (x - 1 | 0) + Caml_int32.mod_(heigth, heigth) | 0,
          y
        ];
        break;
    case 3 : 
        newPosition = /* tuple */[
          x,
          y + Caml_int32.mod_(1, width) | 0
        ];
        break;
    case 4 : 
        newPosition = /* tuple */[
          x,
          Caml_int32.mod_((y - 1 | 0) + width | 0, width)
        ];
        break;
    
  }
  var boardRow = List.nth(board, x);
  var square = List.nth(boardRow, y);
  var match = square !== 0 ? /* tuple */[
      /* Obstacle */1,
      position
    ] : /* tuple */[
      /* Ok */0,
      newPosition
    ];
  var newDirection;
  switch (direction) {
    case 0 : 
        if (m >= 2) {
          switch (m - 2 | 0) {
            case 0 : 
                newDirection = /* East */2;
                break;
            case 1 : 
                newDirection = /* West */3;
                break;
            case 2 : 
                newDirection = direction;
                break;
            
          }
        } else {
          newDirection = direction;
        }
        break;
    case 1 : 
        if (m >= 2) {
          switch (m - 2 | 0) {
            case 0 : 
                newDirection = /* West */3;
                break;
            case 1 : 
                newDirection = /* East */2;
                break;
            case 2 : 
                newDirection = direction;
                break;
            
          }
        } else {
          newDirection = direction;
        }
        break;
    case 2 : 
        if (m >= 2) {
          switch (m - 2 | 0) {
            case 0 : 
                newDirection = /* South */1;
                break;
            case 1 : 
                newDirection = /* North */0;
                break;
            case 2 : 
                newDirection = direction;
                break;
            
          }
        } else {
          newDirection = direction;
        }
        break;
    case 3 : 
        if (m >= 2) {
          switch (m - 2 | 0) {
            case 0 : 
                newDirection = /* North */0;
                break;
            case 1 : 
                newDirection = /* South */1;
                break;
            case 2 : 
                newDirection = direction;
                break;
            
          }
        } else {
          newDirection = direction;
        }
        break;
    
  }
  return /* record */[
          /* board */pluto[/* board */0],
          /* position */match[1],
          /* direction */newDirection,
          /* status */match[0]
        ];
}

function evaluateMoves(moves, pluto) {
  var commands = mapCommandToMove(moves);
  return List.fold_left(evaluateMove, pluto, commands);
}

function createEmptyBoard(heigth, width) {
  var row = Caml_array.caml_make_vect(width, /* Empty */0);
  var listRow = $$Array.to_list(row);
  return $$Array.to_list(Caml_array.caml_make_vect(heigth, listRow));
}

function createOneObstacleInRowBoard(heigth, width, obstacle) {
  var row = Caml_array.caml_make_vect(width, /* Empty */0);
  Caml_array.caml_array_set(row, obstacle, /* Obstacle */1);
  var listRow = $$Array.to_list(row);
  return $$Array.to_list(Caml_array.caml_make_vect(heigth, listRow));
}

function createPluto(startPosition, startDirection, board) {
  return /* record */[
          /* board */board,
          /* position */startPosition,
          /* direction */startDirection,
          /* status : Ok */0
        ];
}

exports.mapCharToMove               = mapCharToMove;
exports.mapCommandToMove            = mapCommandToMove;
exports.evaluateMove                = evaluateMove;
exports.evaluateMoves               = evaluateMoves;
exports.createEmptyBoard            = createEmptyBoard;
exports.createOneObstacleInRowBoard = createOneObstacleInRowBoard;
exports.createPluto                 = createPluto;
/* No side effect */
